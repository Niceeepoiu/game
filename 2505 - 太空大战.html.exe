<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>ğŸ† å¤ªç©ºå¤§æˆ˜ - æœ€ç»ˆæˆ˜å½¹ ğŸ†</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            margin: 0;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            overflow: hidden; 
        }

        #bgCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            z-index: 10;
        }

        #gameCanvas {
            display: block;
            background: transparent;
            z-index: 10;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            box-sizing: border-box;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            font-size: 18px;
            font-weight: bold;
            z-index: 20;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2); 
        }

        .hud-group {
            display: flex;
            align-items: center;
        }

        .hud-item {
            margin-right: 20px;
        }

        .hud-item span {
            margin-left: 5px;
            font-size: 20px;
            color: #ffdd00;
        }
        
        #livesBarContainer {
            width: 120px;
            height: 15px;
            background: #444;
            border-radius: 5px;
            border: 1px solid #fff;
            margin-left: 5px;
        }
        #livesBar {
            height: 100%;
            background: linear-gradient(to right, #ff4d4d, #00ff80);
            border-radius: 5px;
            transition: width 0.3s ease-out;
        }
        
        #pauseButton {
            padding: 8px 15px;
            font-size: 16px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid white;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 15px;
            transition: background 0.2s;
        }
        #pauseButton:hover { background: rgba(255, 255, 255, 0.3); }

        #powerupDisplay {
            position: absolute;
            top: 55px;
            left: 15px;
            color: white;
            font-size: 16px;
            z-index: 20;
        }
        .powerup-active {
            margin-bottom: 5px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 0 5px rgba(255, 255, 0, 0.5);
        }
        .powerup-icon {
            font-size: 20px;
        }
        .powerup-timer {
            color: #00ffc3;
            font-weight: bold;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85); 
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            padding-bottom: 50px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .overlay.show {
            opacity: 1;
        }
        
        .overlay h2 {
            font-size: 56px;
            color: #00c8ff;
            text-shadow: 0 0 15px rgba(0, 200, 255, 1);
            margin-bottom: 20px;
        }
        
        .overlay p {
            font-size: 24px;
            margin: 10px 0;
            line-height: 1.5;
        }

        .key-hint {
            display: inline-block;
            background-color: #333;
            border: 1px solid #fff;
            padding: 2px 8px;
            border-radius: 5px;
            margin: 0 5px;
            font-family: monospace;
            font-weight: bold;
            color: #ffdd00;
        }

        #credit {
            font-size: 16px;
            color: #aaa;
            text-shadow: 0 0 5px #000;
            margin-bottom: 15px; 
            display: block;
        }

        .action-button {
            padding: 18px 35px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            background-color: #0088ff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 6px #0055aa;
            transition: all 0.2s;
            margin-top: 15px; 
        }

        .action-button:hover { background-color: #00aaff; }
        .action-button:active { box-shadow: 0 2px #0055aa; transform: translateY(4px); }

        .action-button-orange {
            background-color: #ff9900;
            box-shadow: 0 6px #cc7700;
        }
        .action-button-orange:hover { 
            background-color: #ffaa00;
        }
        .action-button-orange:active { 
            box-shadow: 0 2px #cc7700;
            transform: translateY(4px);
        }

        /* çº¢è‰²æŒ‰é’®æ ·å¼ï¼ˆå¤§ï¼‰ */
        .action-button-red {
            background-color: #ff4d4d;
            box-shadow: 0 6px #cc3333;
        }
        .action-button-red:hover { 
            background-color: #ff6666;
        }
        .action-button-red:active { 
            box-shadow: 0 2px #cc3333;
            transform: translateY(4px);
        }

        .action-button-red-small {
            background-color: #ff4d4d; 
            box-shadow: 0 4px #cc3333; 
        }
        .action-button-red-small:hover { 
            background-color: #ff6666;
        }
        .action-button-red-small:active { 
            box-shadow: 0 0px #cc3333;
            transform: translateY(4px);
        }

        .action-button-gray {
             background-color: #555;
             box-shadow: 0 6px #333;
        }
        .action-button-gray:hover {
            background-color: #777;
        }
        .action-button-gray:active { 
             box-shadow: 0 2px #333;
             transform: translateY(4px);
        }

        #modeSelectScreen {
            display: none;
        }
        
        #modeCards {
            display: flex;
            gap: 30px;
            margin-bottom: 40px;
        }

        .mode-card {
            width: 300px;
            padding: 20px;
            background: rgba(20, 20, 40, 0.9);
            border: 3px solid #00aaff;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            text-align: left;
        }

        .mode-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 170, 255, 0.5);
        }
        .mode-card.entertainment:hover {
             transform: translateY(-5px);
             box-shadow: 0 10px 20px rgba(255, 153, 0, 0.8);
        }

        .mode-card.selected.entertainment:hover {
             transform: scale(1.05);
             box-shadow: 0 0 15px #ffdd00, 0 0 25px rgba(255, 221, 0, 0.7)
        }

        .mode-card.selected {
            border-color: #ffdd00;
            box-shadow: 0 0 15px #ffdd00, 0 0 25px rgba(255, 221, 0, 0.7);
            transform: scale(1.05);
        }

        .mode-card h3 {
            color: #00ffc3;
            font-size: 28px;
            margin-top: 0;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }

        .mode-card p {
            font-size: 16px;
            color: #ccc;
            margin: 10px 0 0;
            line-height: 1.4;
        }
        .mode-card.entertainment {
             border-color: #ff9900;
        }

        #talentSelectScreen {
            display: none;
        }
        
        #talentSelectScreen h2 {
            margin-bottom: 40px;
        }

        #talentCards {
            display: flex;
            gap: 30px;
            margin-bottom: 40px;
        }

        .talent-card {
            width: 250px;
            padding: 20px;
            background: rgba(20, 20, 40, 0.9);
            border: 3px solid #00c8ff; 
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
            text-align: left;
        }

        .talent-card h3 {
            color: #00ffff;
            font-size: 26px;
            margin-top: 0;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }
        
        .talent-card p {
            font-size: 15px;
            color: #ddd;
            margin: 15px 0 0;
            line-height: 1.5;
        }
        
        .talent-card p b {
            color: #ffc300;
            text-shadow: 0 0 3px #ff0000;
        }

        .talent-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 15px 30px rgba(0, 200, 255, 0.6); 
        }
        
        .talent-card.selected {
            border-color: #ffdd00; 
            box-shadow: 0 0 15px #ffdd00;
            transform: scale(1.08);
        }


        #compendiumScreen {
            overflow-y: auto;
            align-items: center; 
            padding-top: 50px;
            padding-bottom: 100px;
        }
        #compendiumScreen > h2 {
            position: sticky;
            top: 0;
            background: rgba(0, 0, 0, 0.9); 
            width: 100%;
            padding: 20px 0;
            z-index: 10;
            margin-top: -50px;
        }

        #compendiumContent {
            width: 90%;
            max-width: 1200px;
            text-align: left;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
        }
        
        .compendium-section {
            width: 30%;
            min-width: 300px;
            margin-bottom: 30px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .compendium-section h3 {
            font-size: 30px;
            color: #00ff80;
            border-bottom: 3px solid rgba(0, 255, 128, 0.5);
            padding-bottom: 5px;
            margin-top: 10px;
            margin-bottom: 20px;
        }

        .compendium-item {
            display: flex;
            align-items: flex-start;
            padding: 10px;
            background: rgba(30, 30, 50, 0.7);
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .item-icon {
            font-size: 30px;
            margin-right: 15px;
            flex-shrink: 0;
        }

        .item-details {
            flex-grow: 1;
        }

        .item-details h4 {
            font-size: 20px;
            color: #ffdd00;
            margin: 0 0 5px 0;
        }

        .item-details p {
            font-size: 14px;
            margin: 0;
            line-height: 1.3;
        }
        
        .compendium-close {
            position: fixed;
            bottom: 20px;
            margin-top: 30px;
            z-index: 20;
        }

        #pauseScreen {
            display: none;
        }
        
        .pause-actions {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }

        #confirmRestartModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff4d4d;
            padding: 30px;
            border-radius: 15px;
            z-index: 101;
            box-shadow: 0 0 20px rgba(255, 77, 77, 0.8);
            display: none;
        }
        #confirmRestartModal p {
            font-size: 22px;
            color: #ff4d4d;
            margin-bottom: 20px;
        }
        .modal-buttons button {
            margin: 0 10px;
            padding: 10px 20px;
            font-size: 18px;
        }
        
        .signed {
            text-decoration:none;
            color: lightgray;
        }

        #achievementsRow { padding-bottom: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 20px; width: 100%; align-items: start; }
        .achievement-item {
            min-width: 220px;
            background: rgba(30,30,40,0.95);
            border: 2px solid rgba(255,255,255,0.06);
            border-radius: 10px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            color: #ddd;
            box-shadow: 0 6px 12px rgba(0,0,0,0.6);
            transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
            box-sizing: border-box;
            height: 200px;
            overflow: hidden;
        }
        .achievement-item.locked { opacity: 0.45; filter: grayscale(70%); }
        .achievement-icon { font-size: 42px; }
        .achievement-title { font-weight: bold; color: #ffdd00; font-size: 18px; }
        .achievement-desc { font-size: 14px; color: #ddd; text-align:center; min-height:42px; overflow: hidden; display: -webkit-box; -webkit-line-clamp:2; -webkit-box-orient: vertical; }
        .achievement-unlocked-badge { color: #00ff80; font-weight: bold; }

        .achievement-item:hover { transform: translateY(-8px) scale(1.035); box-shadow: 0 14px 30px rgba(0,0,0,0.7); border-color: #ffdd00; }
        .achievement-item.locked:hover { transform: translateY(-6px) scale(1.02); border-color: rgba(255,255,255,0.2); }

        .progress { width: 100%; background: rgba(255,255,255,0.06); height: 10px; border-radius: 6px; overflow: hidden; margin-top:6px; }
        .progress-bar { height:100%; background: linear-gradient(90deg,#ffdd00,#ff9900); width:0%; transition: width 0.4s ease; }

        .achievement-toast {
            position: fixed;
            right: 24px;
            top: 24px;
            transform: translateX(120%);
            opacity: 0;
            padding: 14px 18px;
            background: linear-gradient(90deg, rgba(34, 34, 34, 0.8), rgba(17, 17, 17, 0.8));
            border: 3px solid #ffdd00;
            border-radius: 12px;
            color: white;
            z-index: 9999;
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            min-width: 260px;
            max-width: 420px;
            font-size: 16px;
        }
        .achievement-toast.show { transform: translateX(0); opacity: 1; transition: transform 0.45s cubic-bezier(.2,.9,.3,1), opacity 0.35s; }
        .achievement-toast.hide { transform: translateX(120%); opacity: 0; transition: transform 0.35s ease, opacity 0.35s ease; }

    </style>
</head>
<body>
    <audio id="shoot-sound" src="https://store.soundeffectgenerator.org/instants/laser-sound-effect/5cc5a18c-laser-sound.mp3" preload="auto"></audio>
    
    <audio id="explosion-sound" src="https://store.soundeffectgenerator.org/instants/cartoon-explosion-sound-effect/5f279278-minecraft-explosion.mp3" preload="auto"></audio>
    
    <audio id="background-music" src="https://s1.aigei.com/src/aud/mp3/82/8207c91e93f6458d894a32c35f0c3ae5.mp3?e=1763469600&token=P7S2Xpzfz11vAkASLTkfHN7Fw-oOZBecqeJaxypL:267cdHi3H40A5umII_ak5jgSusw=" loop preload="auto"></audio>
    
    <canvas id="bgCanvas"></canvas>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="hud">
            <div class="hud-group">
                <div class="hud-item">åˆ†æ•°: <span id="currentScore">0</span></div>
                <div class="hud-item" id="gameModeDisplay">æ¨¡å¼: <span style="color: #00c8ff;">æ™®é€š</span></div> 
                <div class="hud-item">
                    ç”Ÿå‘½: 
                    <div id="livesBarContainer">
                        <div id="livesBar"></div>
                    </div>
                </div>
                <div class="hud-item" id="talentCooldownDisplay"></div> 
            </div>
            
            <div class="hud-group">
                <div class="hud-item">æœ€é«˜åˆ†: <span id="highScore">0</span></div>
                <button id="pauseButton">æš‚åœ (P)</button>
            </div>
        </div>

        <div id="powerupDisplay">
            </div>
        
        <div id="startScreen" class="overlay show">
            <h2>ğŸš€ æ¬¢è¿æ¥åˆ°å¤ªç©ºå¤§æˆ˜ ğŸš€</h2>
            <p style="color:#00ffff;">æ§åˆ¶ä½ çš„é£èˆ¹ï¼Œæ‘§æ¯æ‰€æœ‰å¤–æ˜Ÿå…¥ä¾µè€…ï¼</p>
            <p>ç§»åŠ¨: <span class="key-hint">æ–¹å‘é”®</span> æˆ– <span class="key-hint">WASD</span></p>
            <p>å°„å‡»: <span class="key-hint">é¼ æ ‡å·¦é”®</span>(å¯é•¿æŒ‰)</p>
            
            <small id="credit">æ­¤æ¸¸æˆç”± <b class="signed">ä¸ƒ(5)ç­å¾æ½‡æŸ¯</b> åˆ¶ä½œ</small>
            
            <button id="startButton" class="action-button">å¼€å§‹æ¸¸æˆ</button>
            <button id="compendiumButton" class="action-button action-button-orange">æŸ¥çœ‹å›¾é‰´</button>
            <button id="achievementsButton" class="action-button action-button-orange">æŸ¥çœ‹æˆå°±</button>
        </div>
        
        <div id="modeSelectScreen" class="overlay">
            <h2>âš¡ é€‰æ‹©æ¸¸æˆæ¨¡å¼ âš¡</h2>
            <div id="modeCards">
                <div class="mode-card" data-mode="normal">
                    <h3>æ™®é€šæ¨¡å¼ ğŸŒŸ</h3>
                    <p>ç»å…¸ç©æ³•ï¼Œä»æ˜“åˆ°éš¾ï¼ŒæŒ‘æˆ˜ BOSSï¼Œäº‰å¤ºæœ€é«˜åˆ†ï¼</p>
                    <p style="color:#ffdd00; margin-top: 15px;"><b>è®¡å…¥æœ€é«˜åˆ†</b></p>
                </div>
                <div class="mode-card entertainment" data-mode="entertainment_remote">
                    <h3>ä¸­é—¨å¯¹ç‹™ ğŸ›¸</h3>
                    <p>åªç”Ÿæˆè¿œç¨‹ç‚®å°ï¼Œè€ƒéªŒä½ çš„ååº”å’Œèµ°ä½ã€‚æ²¡æœ‰ BOSSï¼Œä¸ç”Ÿæˆé“å…·ã€‚</p>
                    <p style="color:#ff4d4d; margin-top: 15px;"><b>ä¸è®¡å…¥æœ€é«˜åˆ†</b></p>
                </div>
                <div class="mode-card entertainment" data-mode="entertainment_precision">
                    <h3>ç²¾å‡†æ‰“å‡» ğŸ¯</h3>
                    <p>æŒ‡å“ªæ‰“å“ªï¼Œæ™®æ”»å˜ä¸ºé¼ æ ‡ç„å‡†å‘å°„ï¼Œæ²¡æœ‰BOSSï¼Œä¸ç”Ÿæˆé“å…·ã€‚</p>
                    <p style="color:#ff4d4d; margin-top: 15px;"><b>ä¸è®¡å…¥æœ€é«˜åˆ†</b></p>
                </div>
            </div>
            <button id="selectTalentButton" class="action-button" disabled>ç¡®è®¤æ¨¡å¼ï¼Œé€‰æ‹©å¤©èµ‹</button>
            <button id="backToMenuFromModeButton" class="action-button small-button action-button-gray">è¿”å›ä¸»èœå•</button>
        </div>

        <div id="talentSelectScreen" class="overlay">
            <h2>âœ¨ é€‰æ‹©å¤©èµ‹ âœ¨</h2>
            <div id="talentCards">
                </div>
            <p id="selectedTalentHint" style="color:#00ffc3; font-weight:bold;">è¯·é€‰æ‹©ä¸€ä¸ªå¤©èµ‹</p>
            <div style="display: flex; gap: 20px;">
                <button id="confirmTalentButton" class="action-button" disabled>ç¡®è®¤å¤©èµ‹ï¼Œå¼€å§‹æˆ˜æ–—ï¼</button>
                <button id="backToModeSelectButton" class="action-button small-button action-button-gray">è¿”å›æ¨¡å¼é€‰æ‹©</button>
            </div>
        </div>
        
        <div id="compendiumScreen" class="overlay">
            <h2>ğŸ“š æ¸¸æˆå›¾é‰´ ğŸ“š</h2>
            <div id="compendiumContent">
                </div>
            <button id="closeCompendiumButton" class="action-button compendium-close action-button-gray">è¿”å›ä¸»èœå•</button>
        </div>

        <div id="achievementsScreen" class="overlay">
            <h2>ğŸ… æˆå°±</h2>
            <div id="achievementsContainer" style="width:90%; max-width:1200px; padding-top:30px;">
                <div id="achievementsRow" style="padding:20px 10px;">
                    <!-- æˆå°±é¡¹ç”± JS æ¸²æŸ“ -->
                </div>
            </div>
            <button id="closeAchievementsButton" class="action-button compendium-close action-button-gray">è¿”å›ä¸»èœå•</button>
        </div>


        <div id="pauseScreen" class="overlay">
            <h2>â¸ï¸ æ—¶é—´æš‚åœ â¸ï¸</h2>
            <p>ä¼‘æ¯ä¸€ä¸‹ï¼Œå®‡å®™ç­‰ä½ æ‹¯æ•‘ï¼</p>
            
            <div class="pause-actions">
                <button id="resumeButton" class="action-button">ç»§ç»­æ¸¸æˆ</button>
                <button id="showRestartConfirmButton" class="action-button action-button-red">é‡æ–°å¼€å§‹</button>
            </div>
            
            <div id="confirmRestartModal">
                 <p>è­¦å‘Šï¼šé‡æ–°å¼€å§‹å°†ä¸¢å¤±å½“å‰å¾—åˆ† <span style="font-size: 28px;"></span>ï¼</p>
                 <div class="modal-buttons">
                    <button id="confirmRestartButton" class="action-button small-button action-button-red-small">ç¡®è®¤é‡æ–°å¼€å§‹</button>
                    <button id="cancelRestartButton" class="action-button small-button action-button-gray">å–æ¶ˆ</button>
                 </div>
            </div>
        </div>
        
        <div id="gameOverScreen" class="overlay">
            <h2>ğŸ’¥ ä»»åŠ¡å¤±è´¥ï¼ğŸ’¥</h2>
            <p id="modeResultText"></p>
            <p>æœ€ç»ˆå¾—åˆ†:</p>
            <p id="finalScore"></p>
            <p id="highScoreDisplay"></p>
            <div style="display: flex; gap: 20px;">
                <button id="restartButton" class="action-button">é‡æ–°é€‰æ‹©æ¨¡å¼/å¤©èµ‹</button>
                <button id="backToMenuFromGameOverButton" class="action-button small-button action-button-gray">è¿”å›ä¸»èœå•</button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. åˆå§‹åŒ–è®¾ç½® ---
        const gameContainer = document.getElementById('gameContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgCanvas = document.getElementById('bgCanvas');
        const bgCtx = bgCanvas.getContext('2d');

        const FPS = 60;
        let GAME_WIDTH;
        let GAME_HEIGHT;
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
            GAME_WIDTH = canvas.width;
            GAME_HEIGHT = canvas.height;
            initStars(); 
        }
        
        // --- 2. DOMå…ƒç´  ---
        const hudScore = document.getElementById('currentScore');
        const hudHighScore = document.getElementById('highScore');
        const gameModeDisplay = document.getElementById('gameModeDisplay'); 
        const livesBar = document.getElementById('livesBar');
        const powerupDisplay = document.getElementById('powerupDisplay');
        const talentCooldownDisplay = document.getElementById('talentCooldownDisplay');
        const startScreen = document.getElementById('startScreen');
        const modeSelectScreen = document.getElementById('modeSelectScreen'); 
        const modeCardsContainer = document.getElementById('modeCards'); 
        const selectTalentButton = document.getElementById('selectTalentButton'); 
        const backToMenuFromModeButton = document.getElementById('backToMenuFromModeButton'); 
        const backToModeSelectButton = document.getElementById('backToModeSelectButton'); 
        const talentSelectScreen = document.getElementById('talentSelectScreen');
        const talentCardsContainer = document.getElementById('talentCards');
        const confirmTalentButton = document.getElementById('confirmTalentButton');
        const selectedTalentHint = document.getElementById('selectedTalentHint');
        const compendiumScreen = document.getElementById('compendiumScreen'); 
        const compendiumContent = document.getElementById('compendiumContent'); 
        const compendiumButton = document.getElementById('compendiumButton'); 
        const closeCompendiumButton = document.getElementById('closeCompendiumButton'); 
        const achievementsScreen = document.getElementById('achievementsScreen');
        const achievementsContainer = document.getElementById('achievementsContainer');
        const pauseScreen = document.getElementById('pauseScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const modeResultText = document.getElementById('modeResultText'); 
        const finalScoreDisplay = document.getElementById('finalScore');
        const finalHighScoreDisplay = document.getElementById('highScoreDisplay');
        const startButton = document.getElementById('startButton');
        const resumeButton = document.getElementById('resumeButton');
        const restartButton = document.getElementById('restartButton');
        const pauseButton = document.getElementById('pauseButton');
        const showRestartConfirmButton = document.getElementById('showRestartConfirmButton'); 
        const confirmRestartModal = document.getElementById('confirmRestartModal'); 
        const confirmRestartButton = document.getElementById('confirmRestartButton'); 
        const cancelRestartButton = document.getElementById('cancelRestartButton'); 
        const backToMenuFromGameOverButton = document.getElementById('backToMenuFromGameOverButton'); 
        
        const shootSound = document.getElementById('shoot-sound');
        const explosionSound = document.getElementById('explosion-sound');
        const backgroundMusic = document.getElementById('background-music');

        // é¼ æ ‡ä½ç½®ï¼Œç”¨äºç²¾å‡†æ‰“å‡»æ¨¡å¼
        let mouseX = 0, mouseY = 0;

        // --- 3. æ¸¸æˆçŠ¶æ€ ---
        let score = 0;
        let maxLives = 10;
        let lives = maxLives;
        let highScore = 0;
        let gameFrame = 0;
        let isRunning = false;
        let isPaused = false;
        let invulnerabilityTimer = 0;
        let selectedTalent = null;
        let talentCooldown = 0;
        let hasRevived = false;
        let gameMode = 'normal'; 
        let selectedModeCard = null; 

        // --- BossçŠ¶æ€ ---
        let bossLevel = 0;
        let isBossActive = false; 
        let showBossBanner = false;
        let bossBannerTimer = 0;
        const BOSS_BANNER_DURATION = 3 * FPS;
        let scoreToNextBoss = 1000; 

        // --- 4. æ¸¸æˆå¯¹è±¡æ•°ç»„ ---
        let playerBullets = [];
        let enemyBullets = [];
        let enemies = [];
        let powerups = [];
        let explosions = [];
        let strikeLines = []; // ç²¾å‡†æ‰“å‡»æ—¶æ˜¾ç¤ºç©å®¶åˆ°æ‰“å‡»ç‚¹çš„çº¢è‰²çº¿æ¡
        let particles = []; // ç²’å­æ•ˆæœ
        let screenShake = { time: 0, intensity: 0 };
        // æˆå°±è®¡æ•°
        let enemiesKilled = 0;
        let bossesKilled = 0;
        let powerupsCollected = 0;
        let maxBombKills = 0; // è®°å½•å•æ¬¡ç‚¸å¼¹æœ€å¤§è¿æ€ï¼Œç”¨äºè¿›åº¦æ˜¾ç¤º
        let stars = [];
        
        // --- 5. é…ç½® ---
        const CONFIG = {
            PLAYER_BASE_SPEED: 12,
            PLAYER_SPEED_BOOST: 1.5,
            BULLET_SPEED: 15,
            ENEMY_SPEED: 2,
            REMOTE_ENEMY_SPEED: 1.5,
            WANDER_SPEED: 2.5,
            ENEMY_SPAWN_MAX: 100, 
            ENEMY_SPAWN_MIN: 30,
            INVULNERABILITY_DURATION: 60,
            POWERUP_DURATION: 400,
            EXPLOSION_DURATION: 30,
            ENEMY_BULLET_SPEED: 5,
            ENEMY_SHOOT_INTERVAL: 90,
            POWERUP_SPAWN_CHANCE: 0.5,
            
            // å¤©èµ‹ç›¸å…³é…ç½®
            TALENT_INSTAKILL_COOLDOWN: 30, 
            TALENT_IMMORTAL_INVULNERABILITY: 2 * FPS, 
            TALENT_IMMORTAL_COOLDOWN: 5 * FPS, 
            INSTAKILL_BULLET_SPEED_MULTIPLIER: 3.5, 
            
            // Bossç›¸å…³é…ç½®
            BOSS_BASE_HP: 50,
            BOSS_HP_FACTOR: 1.5, 
            BOSS_SPEED: 1.0,
            BOSS_SHOOT_INTERVAL: 40,
            BOSS_POINTS: 1000
        };
        
        // --- 6. é“å…·æ•°æ® (ç”¨äºæ˜¾ç¤ºå’Œé€»è¾‘) ---
        let activePowerups = []; 

        const POWERUP_DETAILS = {
            'double': { icon: 'âš¡', name: 'åŒå€ç«åŠ›', desc: 'ä½¿é£èˆ¹åœ¨çŸ­æ—¶é—´å†…åŒæ—¶å‘å°„ä¸¤é¢—å­å¼¹ã€‚' },
            'bomb': { icon: 'ğŸ’£', name: 'ç‚¸å¼¹å­å¼¹', desc: 'å‘å°„çš„å­å¼¹çˆ†ç‚¸äº§ç”ŸèŒƒå›´ä¼¤å®³ã€‚ä¸€æªç¬ç§’å¤©èµ‹å¯æå‡å…¶å¨åŠ›ã€‚' },
            'heal': { icon: 'ğŸ’š', name: 'ç”Ÿå‘½å›å¤', desc: 'ç«‹å³æ¢å¤ 2 ç‚¹ç”Ÿå‘½å€¼ã€‚' },
            'speed': { icon: 'ğŸ’¨', name: 'é€Ÿåº¦æå‡', desc: 'æå‡é£èˆ¹ç§»åŠ¨é€Ÿåº¦ã€‚' }
        };
        
        // --- 7. æ•Œäººæ•°æ® (ç”¨äºå›¾é‰´å’Œç”Ÿæˆ) ---
        const ENEMY_DETAILS = {
            'wander': { icon: 'ğŸ‘½', name: 'æ¸¸è¡è€…', desc: 'ä½è¡€é‡ï¼Œä¼šå·¦å³ç§»åŠ¨ï¼Œæ˜“è¢«å‡»æ€ã€‚', health: 2, points: 15, width: 40, height: 40, speed: CONFIG.WANDER_SPEED, isExplosive: true },
            'remote': { icon: 'ğŸ›¸', name: 'è¿œç¨‹ç‚®å°', desc: 'ä¸­è¡€é‡ï¼Œåœ¨å±å¹•ä¸Šæ–¹å›ºå®šä½ç½®å°„å‡»ï¼Œæœ‰è§„å¾‹ã€‚', health: 3, points: 25, width: 50, height: 50, speed: CONFIG.REMOTE_ENEMY_SPEED, isExplosive: false },
            'basic': { icon: 'ğŸ‘¾', name: 'ç´«è‰²å¦å…‹', desc: 'é«˜è¡€é‡ï¼Œç›´çº¿å‘ä¸‹ç§»åŠ¨ï¼Œå¨èƒè¾ƒå¤§ã€‚', health: 6, points: 50, width: 60, height: 60, speed: CONFIG.ENEMY_SPEED, isExplosive: true },
            'boss': { icon: 'ğŸ‘‘', name: 'è¡Œæ˜Ÿæ¯ç­è€…', desc: 'æ¯1000åˆ†å‡ºç°ä¸€æ¬¡ã€‚è¡€é‡å’Œç«åŠ›éšç­‰çº§æå‡ã€‚', health_base: CONFIG.BOSS_BASE_HP, points: CONFIG.BOSS_POINTS, width: 200, height: 100, speed: CONFIG.BOSS_SPEED }
        };
        
        // --- 8. ç©å®¶å¯¹è±¡ ---
        const player = {
            x: 0,
            y: 0,
            width: 50,
            height: 50,
            icon: 'ğŸš€',
            shooting: false,
            cooldown: 0,
            MAX_COOLDOWN: 10
        };
        
        // --- 9. å¤©èµ‹æ•°æ® ---
        const TALENTS = [
            {
                id: 'immortal',
                name: 'ä¸æ­»æˆ˜ç¥ âš”ï¸',
                desc: `å½“ç”Ÿå‘½å€¼å½’é›¶æ—¶ï¼Œç«‹å³è·å¾—<b style="color:#00ffff;">${Math.ceil(CONFIG.TALENT_IMMORTAL_INVULNERABILITY / FPS)}sæ— æ•Œ</b>ï¼Œå¹¶è¿›å…¥<b style="color:#ff4d4d;">${Math.ceil(CONFIG.TALENT_IMMORTAL_COOLDOWN / FPS)}så†·å´</b>ã€‚`
            },
            {
                id: 'instakill',
                name: 'ä¸€æªç¬ç§’ ğŸ”¥',
                desc: `ç©å®¶å­å¼¹è·å¾—<b style="color:#ff00ff;">ç§’æ€</b>èƒ½åŠ›ï¼Œå­å¼¹é€Ÿåº¦æå‡<b style="color:#ffdd00;">${CONFIG.INSTAKILL_BULLET_SPEED_MULTIPLIER}å€</b><b style="color:#ffdd00;"></b>ã€‚å‰¯ä½œç”¨ï¼šå°„å‡»å†·å´æ—¶é—´å¢åŠ ${Math.ceil(CONFIG.TALENT_INSTAKILL_COOLDOWN / player.MAX_COOLDOWN)}å€ã€‚`
            },
            {
                id: 'tank',
                name: 'é‡è£…å¦å…‹ â¤ï¸',
                desc: `åˆå§‹<b style="color:#00ff80;">ç”Ÿå‘½å€¼ç¿»å€</b>ï¼Œå¹¶è·å¾—ä¸€æ¬¡<b style="color:#00ff80;">å¤æ´»</b>æœºä¼šã€‚å¤æ´»åæ¢å¤ä¸ºåŠè¡€ï¼Œä¸”æ— æ³•å†æ¬¡å¤æ´»ã€‚`
            }
        ];

        // --- 10. é”®ç›˜æ§åˆ¶ ---
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'p' || e.key === 'P') {
                if (isRunning && !confirmRestartModal.style.display.includes('flex')) togglePause();
            }
            if (e.key === 'Escape') {
                if (isRunning && isPaused && !confirmRestartModal.style.display.includes('flex')) togglePause();
                if (confirmRestartModal.style.display.includes('flex')) hideRestartConfirmModal();
            }
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            if (e.key === ' ' || e.key === 'Spacebar') {
                player.shooting = false;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                mouseLeftDown = true;
                if (isRunning && !isPaused) {
                    player.shooting = true;
                }
            }
        });

    // é¼ æ ‡æ¾å¼€äº‹ä»¶ç›‘å¬
    canvas.addEventListener('mouseup', (e) => {
        if (e.button === 0) {
            mouseLeftDown = false;
            player.shooting = false;
        }
    });

    canvas.addEventListener('mouseenter', () => {
        // å½“é¼ æ ‡ç§»å…¥æ—¶ï¼Œå¦‚æœå·¦é”®ä»ç„¶å¤„äºæŒ‰ä¸‹çŠ¶æ€ï¼Œåˆ™ç»§ç»­å°„å‡»
        if (mouseLeftDown && isRunning && !isPaused) {
            player.shooting = true;
        }
    });

        // é¼ æ ‡ç§»åŠ¨ï¼Œç”¨äºç„å‡†
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        // --- 11. å­˜å‚¨å’Œç¢°æ’ ---
        function loadHighScore() {
            const savedScore = localStorage.getItem('ultimate_shooter_high_score');
            highScore = parseInt(savedScore) || 0;
            hudHighScore.textContent = highScore;
        }

        function saveHighScore() {
            // å¨±ä¹æ¨¡å¼ä¸ä¿å­˜æœ€é«˜åˆ†
            if (gameMode !== 'normal') return; 
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('ultimate_shooter_high_score', highScore);
            }
            hudHighScore.textContent = highScore;
        }
        
        function checkCollision(obj1, obj2) {
            return (
                obj1.x < obj2.x + obj2.width &&
                obj1.x + obj1.width > obj2.x &&
                obj1.y < obj2.y + obj2.height &&
                obj1.y + obj2.height > obj2.y
            );
        }

        // --- 12. ç»˜åˆ¶å‡½æ•° ---

        function initStars() {
            // æ¸…é™¤æ—§æ˜Ÿæ˜Ÿæ•°ç»„ï¼Œé‡æ–°åˆå§‹åŒ–ä»¥é€‚åº”æ–°çš„ canvas å¤§å°
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * bgCanvas.width,
                    y: Math.random() * bgCanvas.height,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 0.5 + 0.1,
                    color: `rgba(255, 255, 255, ${Math.random() * 0.8 + 0.2})`
                });
            }
        }

        function drawBackground() {
            bgCtx.fillStyle = 'black';
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

            stars.forEach(star => {
                bgCtx.fillStyle = star.color;
                bgCtx.beginPath();
                bgCtx.arc(star.x, star.y, star.size / 2, 0, Math.PI * 2);
                bgCtx.fill();

                star.y += star.speed;

                if (star.y > bgCanvas.height) {
                    star.y = 0;
                    star.x = Math.random() * bgCanvas.width;
                }
            });
        }

        function drawPlayer() {
            if (invulnerabilityTimer > 0 && invulnerabilityTimer % 6 < 3) {
                return;
            }
            
            ctx.font = `${player.width}px Arial`;
            ctx.textAlign = 'left';
            ctx.fillText(player.icon, player.x, player.y + player.height * 0.8);
        }

        // --- MODIFIED: ç©å®¶å­å¼¹ä¼˜åŒ–ï¼ˆå…‰æ™•ä¸æ ¸å¿ƒï¼‰ ---
        function drawPlayerBullets() {
            playerBullets.forEach(bullet => {
                let color, glowColor;
                let radius = 3;
                let isBomb = hasPowerup('bomb');
                
                if (bullet.type === 'instakill' || (bullet.type === 'instakill' && isBomb)) { 
                     color = '#ff00ff'; glowColor = '#ff00ff'; radius = isBomb ? 6 : 4; // ç´«è‰²æ ¸å¿ƒ/å…‰æ™•
                } else if (bullet.type === 'bomb') { 
                     color = '#ffdd55'; glowColor = '#ff9900'; radius = 6; // é»„è‰²æ ¸å¿ƒï¼Œæ©™è‰²å…‰æ™•
                } else { 
                     color = '#ffffff'; glowColor = '#00ffff'; radius = 3; // ç™½è‰²æ ¸å¿ƒï¼Œé’è‰²å…‰æ™•
                }

                const cx = bullet.x + bullet.width / 2;
                const cy = bullet.y + bullet.height / 2;
                
                // 1. ç»˜åˆ¶å…‰æ™•
                ctx.save();
                ctx.shadowBlur = radius * 3;
                ctx.shadowColor = glowColor; 
                
                // 2. ç»˜åˆ¶æ ¸å¿ƒ
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 3. ç»˜åˆ¶æ‹–å°¾æ•ˆæœ
                ctx.fillStyle = glowColor + '30';
                ctx.beginPath();
                ctx.ellipse(cx, cy + radius * 3, radius * 1.5, radius * 5, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            });
        }

        // --- MODIFIED: æ•Œäººå­å¼¹ä¼˜åŒ–ï¼ˆçƒ­é‡å…‰æ™•å’Œæ‹–å°¾ï¼‰ ---
        function drawEnemyBullets() {
            enemyBullets.forEach(bullet => {
                const size = 8;
                const cx = bullet.x + bullet.width / 2;
                const cy = bullet.y + bullet.height / 2;
                
                // 1. ç»˜åˆ¶å…‰æ™•
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff4d4d';
                
                // 2. ç»˜åˆ¶æ‹–å°¾/å°¾ç„°
                ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                ctx.beginPath();
                ctx.moveTo(cx - size / 2, cy);
                ctx.lineTo(cx + size / 2, cy);
                ctx.lineTo(cx, cy + size * 2);
                ctx.closePath();
                ctx.fill();
                
                // 3. ç»˜åˆ¶æ ¸å¿ƒ
                ctx.fillStyle = 'red';
                ctx.translate(cx, cy);
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-size/2, -size/2, size, size);
                
                ctx.restore();
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                const iconSize = enemy.type === 'boss' ? enemy.width * 0.5 : enemy.width * 0.7;
                ctx.font = `${iconSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(enemy.icon, enemy.x + enemy.width / 2, enemy.y + enemy.height * 0.9);
                
                const barWidth = enemy.width;
                ctx.fillStyle = 'red';
                ctx.fillRect(enemy.x, enemy.y - 8, barWidth, 3);
                
                if (enemy.type === 'boss') {
                    ctx.fillStyle = '#ff00c3';
                    ctx.fillRect(enemy.x, enemy.y - 8, barWidth * (enemy.health / enemy.maxHealth), 3);
                    
                    ctx.font = '16px Arial';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.fillText(`LV.${bossLevel}`, enemy.x + enemy.width / 2, enemy.y - 15);
                } else {
                    ctx.fillStyle = '#00ff80';
                    ctx.fillRect(enemy.x, enemy.y - 8, barWidth * (enemy.health / enemy.maxHealth), 3);
                }
            });
        }

        function drawPowerups() {
            powerups.forEach(p => {
                ctx.font = `${p.width}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(POWERUP_DETAILS[p.type].icon, p.x + p.width / 2, p.y + p.height * 0.8);
            });
        }

        function drawExplosions() {
            explosions = explosions.filter(exp => {
                const elapsedRatio = exp.frame / CONFIG.EXPLOSION_DURATION;
                const maxRadius = exp.size * 1.5;

                // åœ¨é¦–æ¬¡ç»˜åˆ¶æ—¶ç”Ÿæˆç²’å­å¹¶è§¦å‘æŠ–åŠ¨
                if (!exp._particlesSpawned) {
                    exp._particlesSpawned = true;
                    const particleCount = Math.min(60, Math.ceil(exp.size / 2));
                    spawnParticles(exp.x, exp.y, particleCount, 'rgba(255,180,60,0.9)', exp.size * 0.12);
                    // æŠ–åŠ¨æ—¶é•¿ä¸å¼ºåº¦æŒ‰çˆ†ç‚¸å¤§å°ç¼©æ”¾
                    screenShake.time = Math.max(screenShake.time, Math.ceil(exp.size / 15));
                    screenShake.intensity = Math.max(screenShake.intensity, Math.min(12, Math.ceil(exp.size / 25)));
                }

                // çˆ†ç‚¸å¯è§å…‰ç¯
                const alpha = 1 - elapsedRatio;
                const radius = maxRadius * elapsedRatio;

                if (radius > 0) {
                    ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(exp.x, exp.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                exp.frame++;
                return exp.frame < CONFIG.EXPLOSION_DURATION;
            });
        }

        // ç²’å­ç³»ç»Ÿ
        function spawnParticles(x, y, count, color, baseSize) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 6 + 1;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: Math.random() * 30 + 20,
                    maxLife: Math.random() * 30 + 20,
                    size: Math.max(1, baseSize * (Math.random() * 1.2 + 0.2)),
                    color: color
                });
            }
        }

        function updateAndDrawParticles() {
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.vy += 0.12; // é‡åŠ›
                p.life--;

                const alpha = Math.max(0, p.life / p.maxLife);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // ç²¾å‡†æ‰“å‡»ç„å‡†ç‰¹æ•ˆ
        function drawAim() {
            if (gameMode !== 'entertainment_precision' || !isRunning) return;

            const x = mouseX;
            const y = mouseY;

            // ç¯å½¢ç„å‡†å™¨
            ctx.save();
            ctx.strokeStyle = '#ff3333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, 24, 0, Math.PI * 2);
            ctx.stroke();

            // åå­—
            ctx.beginPath();
            ctx.moveTo(x - 18, y);
            ctx.lineTo(x - 6, y);
            ctx.moveTo(x + 6, y);
            ctx.lineTo(x + 18, y);
            ctx.moveTo(x, y - 18);
            ctx.lineTo(x, y - 6);
            ctx.moveTo(x, y + 6);
            ctx.lineTo(x, y + 18);
            ctx.stroke();

            ctx.restore();
        }

        function drawStrikeLines() {
            if (!strikeLines.length) return;

            strikeLines = strikeLines.filter(line => line.life > 0);

            strikeLines.forEach(line => {
                const alpha = line.life / line.maxLife * 0.7; // åŠé€æ˜
                ctx.save();
                ctx.strokeStyle = `rgba(255,50,50,${alpha})`;
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.stroke();
                ctx.restore();

                line.life--;
            });
        }
        
        function drawBossBanner() {
            if (!showBossBanner) return;

            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.fillRect(0, GAME_HEIGHT / 2 - 50, GAME_WIDTH, 100);

            ctx.font = '50px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText(`ğŸš¨ BOSS è­¦æŠ¥ï¼ç¬¬ ${bossLevel} é˜¶æ®µ ğŸš¨`, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 15);
            
            bossBannerTimer--;

            if (bossBannerTimer <= 0) {
                showBossBanner = false;
                spawnBoss(bossLevel);
            }
        }

        // --- 13. æ¸¸æˆé€»è¾‘æ›´æ–° ---

        // è¾…åŠ©å‡½æ•°ï¼Œç”¨äºæ˜¾ç¤º/éšè—ç•Œé¢å¹¶æ·»åŠ è¿‡æ¸¡åŠ¨ç”»
        function toggleOverlay(element, show) {
            if (show) {
                element.style.display = 'flex';
                // å¼ºåˆ¶é‡ç»˜ä»¥ç¡®ä¿è¿‡æ¸¡åŠ¨ç”»ç”Ÿæ•ˆ
                element.offsetWidth; 
                element.classList.add('show');
            } else {
                element.classList.remove('show');
                // ç›‘å¬è¿‡æ¸¡ç»“æŸäº‹ä»¶
                setTimeout(() => {
                    if (!element.classList.contains('show')) {
                        element.style.display = 'none';
                    }
                }, 500); // å¿…é¡»å¤§äºCSSè¿‡æ¸¡æ—¶é—´ (0.5s)
            }
        }

        function togglePause() {
            if (!isRunning) return;
            isPaused = !isPaused;
            if (isPaused) {
                toggleOverlay(pauseScreen, true);
                if (backgroundMusic) backgroundMusic.pause();
                pauseButton.textContent = 'ç»§ç»­ (P)';
                // éšè—ç¡®è®¤é‡æ–°å¼€å§‹å¼¹çª—
                hideRestartConfirmModal(); 
                // æš‚åœæ—¶å…è®¸æ–‡å­—é€‰æ‹©
                document.body.style.userSelect = 'auto';
                // æš‚åœæ—¶æ¢å¤å…‰æ ‡
                canvas.style.cursor = 'default';
            } else {
                toggleOverlay(pauseScreen, false);
                pauseButton.textContent = 'æš‚åœ (P)';
                requestAnimationFrame(gameLoop);
                // ç»§ç»­æ¸¸æˆæ—¶ç¦ç”¨æ–‡å­—é€‰æ‹©
                if (backgroundMusic) backgroundMusic.play().catch(e => console.error("èƒŒæ™¯éŸ³ä¹ç»§ç»­æ’­æ”¾å¤±è´¥:", e));
                document.body.style.userSelect = 'none';
                // ç»§ç»­æ¸¸æˆæ—¶å¦‚æœä¸ºç²¾å‡†æ‰“å‡»æ¨¡å¼åˆ™éšè—å…‰æ ‡
                if (gameMode === 'entertainment_precision') {
                    canvas.style.cursor = 'none';
                }
            }
        }
        
        // é‡æ–°å¼€å§‹ç¡®è®¤å¼¹çª—æ§åˆ¶
        function showRestartConfirmModal() {
             confirmRestartModal.style.display = 'block';
             document.querySelector('#confirmRestartModal p').innerHTML = `è­¦å‘Šï¼šé‡æ–°å¼€å§‹å°†ä¸¢å¤±å½“å‰å¾—åˆ† <span style="font-size: 28px;"></span>ï¼`;
        }
        function hideRestartConfirmModal() {
             confirmRestartModal.style.display = 'none';
        }
        
        function hasPowerup(type) {
            return activePowerups.some(p => p.type === type);
        }

        function updatePlayer() {
            const isSpeedBoosted = hasPowerup('speed');
            // Instakill å°„é€Ÿæå‡ 2 å€
            const speedMultiplier = selectedTalent === 'instakill' ? CONFIG.INSTAKILL_BULLET_SPEED_MULTIPLIER : 1;
            const currentSpeed = isSpeedBoosted ? CONFIG.PLAYER_BASE_SPEED * CONFIG.PLAYER_SPEED_BOOST : CONFIG.PLAYER_BASE_SPEED;
            
            // ç§»åŠ¨
            if ((keys['ArrowLeft'] || keys['a']) && player.x > 0) { player.x -= currentSpeed; }
            if ((keys['ArrowRight'] || keys['d']) && player.x < GAME_WIDTH - player.width) { player.x += currentSpeed; }
            if ((keys['ArrowUp'] || keys['w']) && player.y > 0) { player.y -= currentSpeed; }
            if ((keys['ArrowDown'] || keys['s']) && player.y < GAME_HEIGHT - player.height) { player.y += currentSpeed; }
            
            // å°„å‡»
            if (player.shooting && player.cooldown === 0) {
                
                shootSound.currentTime = 0;
                shootSound.play().catch(e => console.error('æ’­æ”¾éŸ³æ•ˆå¤±è´¥', e));
                
                const isDouble = hasPowerup('double');
                const isBomb = hasPowerup('bomb');
                const isInstakill = selectedTalent === 'instakill';

                const baseBulletSpeed = CONFIG.BULLET_SPEED * (isInstakill ? speedMultiplier : 1);

                // ç²¾å‡†æ‰“å‡»æ¨¡å¼ï¼šå­å¼¹æœå‘é¼ æ ‡ä½ç½®ï¼Œä¼¤å®³ç¿»å€ï¼Œå°„é€Ÿå‡åŠ(å†·å´ç¿»å€)
                if (gameMode === 'entertainment_precision') {
                    // ç²¾å‡†æ‰“å‡»ï¼šç¬å‘å‘½ä¸­é¼ æ ‡ä½ç½®ï¼Œç›´æ¥å¯¹è¯¥ç‚¹é™„è¿‘æ•Œäººé€ æˆä¼¤å®³ï¼ˆä¸ç”Ÿæˆå­å¼¹ï¼‰
                    const strikeX = mouseX;
                    const strikeY = mouseY;
                    const strikeRadius = 36; // å‘½ä¸­åˆ¤å®šåŠå¾„
                    const strikeDamage = 2; // ä¼¤å®³ç¿»å€

                    // ç‰¹æ•ˆ
                    explosions.push({x: strikeX, y: strikeY, size: 60, frame: 0});

                    // æ·»åŠ ä»ç©å®¶åˆ°æ‰“å‡»ç‚¹çš„åŠé€æ˜çº¢è‰²ç²—çº¿ï¼ˆç”¨äºçŸ­æš‚æ˜¾ç¤ºï¼‰
                    const px = player.x + player.width / 2;
                    const py = player.y + player.height / 2;
                    strikeLines.push({x1: px, y1: py, x2: strikeX, y2: strikeY, life: 18, maxLife: 18});

                    // ç›´æ¥æ£€æµ‹å¹¶å¤„ç†é™„è¿‘æ•Œäºº
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const ex = enemy.x + enemy.width / 2;
                        const ey = enemy.y + enemy.height / 2;
                        const d = Math.hypot(ex - strikeX, ey - strikeY);
                        if (d <= strikeRadius) {
                            enemy.health -= strikeDamage;
                            if (enemy.health <= 0) {
                                if (enemy.type !== 'boss') {
                                    score += enemy.points;
                                    explosionSound.currentTime = 0;
                                    explosionSound.play().catch(e => console.error('æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆå¤±è´¥', e));
                                }
                                explosions.push({x: ex, y: ey, size: enemy.width * 0.5, frame: 0});
                                // æ ‡è®°ä¸ºå·²è¢«å¤„ç†ä¸ºæ­»äº¡
                                enemy.health = -999;
                            }
                        }
                    }

                    // ç²¾å‡†æ¨¡å¼å°„é€Ÿå‰Šå¼±
                    player.cooldown = Math.ceil(player.MAX_COOLDOWN * 2);
                } else {
                    // ä¼ ç»Ÿæ¨¡å¼ï¼šæ²¿ç«–ç›´æ–¹å‘å‘å°„ï¼ˆåŒ…å«å¤©èµ‹ä¸é“å…·ç»„åˆï¼‰
                    let bulletTypes = [];
                    if (isInstakill) bulletTypes.push('instakill');
                    if (isBomb) bulletTypes.push('bomb');
                    if (!isInstakill && !isBomb) bulletTypes.push('normal');

                    // ç»Ÿä¸€å¤„ç†åŒå‘é€»è¾‘
                    let firePositions = [{x: player.x + player.width / 2 - 2}];
                    if (isDouble) {
                        firePositions = [
                            {x: player.x + 10}, 
                            {x: player.x + player.width - 14}
                        ];
                    }

                    firePositions.forEach(pos => {
                        bulletTypes.forEach(type => {
                            let bulletWidth = 8, bulletHeight = 8;

                            playerBullets.push({
                                x: pos.x, y: player.y,
                                width: bulletWidth, height: bulletHeight, 
                                damage: 1, type: type,
                                speed: baseBulletSpeed
                            });
                        });
                    });

                    player.cooldown = isInstakill ? CONFIG.TALENT_INSTAKILL_COOLDOWN : player.MAX_COOLDOWN;
                }
            }
            if (player.cooldown > 0) { player.cooldown--; }
            if (invulnerabilityTimer > 0) { invulnerabilityTimer--; }
            
            activePowerups = activePowerups.filter(p => {
                p.duration--;
                return p.duration > 0;
            });
            if (talentCooldown > 0) { talentCooldown--; }
        }

        function updatePlayerBullets() {
            playerBullets.forEach(bullet => {
                if (typeof bullet.vx === 'number' && typeof bullet.vy === 'number') {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                } else {
                    bullet.y -= bullet.speed;
                }
            });
            playerBullets = playerBullets.filter(bullet => bullet.y > -100 && bullet.y < GAME_HEIGHT + 100 && bullet.x > -100 && bullet.x < GAME_WIDTH + 100);
        }

        function enemyShoot(enemy) {
            enemyBullets.push({
                x: enemy.x + enemy.width / 2 - 4, y: enemy.y + enemy.height,
                width: 8, height: 8, damage: 1 
            });
        }
        
        function updateEnemyBullets() {
            enemyBullets.forEach(bullet => {
                bullet.y += CONFIG.ENEMY_BULLET_SPEED;
            });
            enemyBullets = enemyBullets.filter(bullet => bullet.y < GAME_HEIGHT + 50);
        }
        
        // --- Boss/Enemy ç”Ÿæˆé€»è¾‘ ---
        function spawnBoss(level) {
            // éæ™®é€šæ¨¡å¼ä¸ç”Ÿæˆ BOSSï¼ˆå¨±ä¹æ¨¡å¼ä¸å‡ºç° Bossï¼‰
            if (gameMode !== 'normal') return;
            
            const bossData = ENEMY_DETAILS.boss;
            const baseHp = bossData.health_base;
            const bossHealth = Math.floor(baseHp * Math.pow(CONFIG.BOSS_HP_FACTOR, level));

            const boss = {
                x: GAME_WIDTH / 2 - bossData.width / 2, y: -bossData.height, 
                width: bossData.width, height: bossData.height,
                icon: bossData.icon,
                health: bossHealth, maxHealth: bossHealth, points: bossData.points * level, 
                type: 'boss',
                shootTimer: 0,
                isExplosive: false,
                isMovingIn: true,
                targetY: 150,
                direction: Math.random() < 0.5 ? 1 : -1 
            };
            enemies.push(boss);
        }

        function spawnEnemy() {
            // æ™®é€šæ¨¡å¼çš„ BOSS è§¦å‘é€»è¾‘
            if (gameMode === 'normal') {
                if (score >= scoreToNextBoss && !isBossActive && !showBossBanner) {
                    showBossBanner = true;
                    bossBannerTimer = BOSS_BANNER_DURATION;
                    bossLevel++;
                    isBossActive = true; 
                    return;
                }
                if (isBossActive || showBossBanner) return; 
            } else if (gameMode === 'entertainment_remote') {
                // å¨±ä¹æ¨¡å¼æ²¡æœ‰ BOSS
            }
            
            const spawnRate = CONFIG.ENEMY_SPAWN_MAX - (score * 0.1);
            let interval = Math.max(CONFIG.ENEMY_SPAWN_MIN, spawnRate);
            let type;
            let data;
            
            if (gameMode === 'entertainment_remote') {
                 // ä¸­é—¨å¯¹ç‹™æ¨¡å¼ï¼šåªç”Ÿæˆ remoteï¼Œä¸”é€Ÿåº¦æ›´å¿«
                 type = 'remote';
                 data = ENEMY_DETAILS[type];
                 // è¿œç¨‹ç‚®å°æ•°é‡å¢åŠ ï¼Œç”Ÿæˆé—´éš”å‡å°ï¼Œä¸”ä¸ä½äº10å¸§
                 interval = Math.max(10, interval / 2); 
            } else { // æ™®é€šæ¨¡å¼
                const rand = Math.random();
                if (rand < 0.45) { type = 'wander'; } 
                else if (rand < 0.75) { type = 'remote'; } 
                else { type = 'basic'; }
                data = ENEMY_DETAILS[type];
            }
            
            if (gameFrame % Math.floor(interval) === 0) {
                const enemy = {
                    x: Math.random() * (GAME_WIDTH - data.width), y: -data.height, 
                    width: data.width, height: data.height,
                    icon: data.icon, health: data.health, maxHealth: data.health, 
                    points: data.points, type: type,
                    isExplosive: data.isExplosive
                };

                if (type === 'wander') {
                    enemy.direction = Math.random() < 0.5 ? 1 : -1;
                } else if (type === 'remote') {
                    // ä¸­é—¨å¯¹ç‹™æ¨¡å¼çš„è¿œç¨‹ç‚®å°ï¼Œå°„å‡»é¢‘ç‡æ›´å¿«
                    const shootInterval = gameMode === 'entertainment_remote' ? CONFIG.ENEMY_SHOOT_INTERVAL / 1.5 : CONFIG.ENEMY_SHOOT_INTERVAL; 
                    enemy.shootTimer = Math.floor(Math.random() * shootInterval);
                    enemy.shootInterval = shootInterval;
                }
                
                enemies.push(enemy);
            }
        }
        
        function updateEnemies() {
            enemies = enemies.filter(enemy => {
                // Boss é€»è¾‘ 
                if (enemy.type === 'boss') {
                    if (enemy.isMovingIn) {
                        enemy.y += CONFIG.BOSS_SPEED;
                        if (enemy.y >= enemy.targetY) {
                            enemy.y = enemy.targetY;
                            enemy.isMovingIn = false;
                        }
                    } else {
                         // Boss æ¨ªå‘ç§»åŠ¨
                         enemy.x += CONFIG.BOSS_SPEED * enemy.direction * 0.5;
                         if (enemy.x <= 0 || enemy.x >= GAME_WIDTH - enemy.width) {
                            enemy.direction *= -1;
                            enemy.x = Math.max(0, Math.min(enemy.x, GAME_WIDTH - enemy.width));
                         }
                         
                         // Boss å°„å‡»é€»è¾‘
                         enemy.shootTimer++;
                         if (enemy.shootTimer >= CONFIG.BOSS_SHOOT_INTERVAL) {
                             const bulletCount = bossLevel + 2;
                             for(let i = 0; i < bulletCount; i++) {
                                  enemyBullets.push({
                                      x: enemy.x + (enemy.width / (bulletCount + 1)) * (i + 1),
                                      y: enemy.y + enemy.height,
                                      width: 8, height: 8, damage: 1
                                  });
                             }
                             enemy.shootTimer = 0;
                         }
                    }
                    return true;
                }
                
                // æ¸¸è¡ç€é€»è¾‘ 
                if (enemy.type === 'remote') {
                    if (enemy.y < GAME_HEIGHT / 3) {
                        enemy.y += CONFIG.REMOTE_ENEMY_SPEED;
                    } else {
                        enemy.shootTimer++;
                        // ä½¿ç”¨ enemy è‡ªèº«çš„ shootInterval
                        if (enemy.shootTimer >= enemy.shootInterval) { 
                            enemyShoot(enemy);
                            enemy.shootTimer = 0;
                        }
                    }
                } else if (enemy.type === 'wander') {
                    enemy.y += CONFIG.ENEMY_SPEED * 0.5;
                    enemy.x += CONFIG.WANDER_SPEED * enemy.direction;
                    
                    if (enemy.x <= 0 || enemy.x >= GAME_WIDTH - enemy.width) {
                        enemy.direction *= -1;
                        enemy.x = Math.max(0, Math.min(enemy.x, GAME_WIDTH - enemy.width));
                    }
                } else { // basic 
                    enemy.y += CONFIG.ENEMY_SPEED;
                }
                
                if (enemy.y > GAME_HEIGHT) {
                    if (enemy.type !== 'boss') { 
                        lives--;
                    }
                    return false;
                }
                return true;
            });
        }
        
        function spawnPowerup(x, y) {
            // å¨±ä¹æ¨¡å¼ä¸æ‰è½é“å…·
            if (gameMode !== 'normal') return;
            
            if (Math.random() < CONFIG.POWERUP_SPAWN_CHANCE) {
                const types = Object.keys(POWERUP_DETAILS);
                const type = types[Math.floor(Math.random() * types.length)];
                
                if (type === 'heal' && lives === maxLives) return;

                powerups.push({
                    x: x - 15, y: y - 15,
                    width: 30, height: 30,
                    type: type
                });
            }
        }
        
        function applyPowerup(p) {
            if (p.type === 'heal') {
                lives = Math.min(maxLives, lives + 2);
            } else {
                const existingIndex = activePowerups.findIndex(ap => ap.type === p.type);
                if (existingIndex > -1) {
                    activePowerups[existingIndex].duration = CONFIG.POWERUP_DURATION;
                } else {
                    activePowerups.push({
                        type: p.type,
                        duration: CONFIG.POWERUP_DURATION
                    });
                }
            }
        }

        function updatePowerups() {
            powerups.forEach(p => {
                p.y += 2;
            });
            powerups = powerups.filter(p => p.y < GAME_HEIGHT);
        }

        function updateExplosions() {
             // çˆ†ç‚¸å¸§æ•°åœ¨ drawExplosions ä¸­æ›´æ–°
        }
        
        function updatePowerupDisplay() {
            powerupDisplay.innerHTML = '';
            activePowerups.forEach(p => {
                const remainingSeconds = Math.ceil(p.duration / FPS);
                const detail = POWERUP_DETAILS[p.type];
                
                if (remainingSeconds > 0) {
                    const div = document.createElement('div');
                    div.className = 'powerup-active';
                    div.innerHTML = `<span class="powerup-icon">${detail.icon}</span> ${detail.name}: <span class="powerup-timer">${remainingSeconds}s</span>`;
                    powerupDisplay.appendChild(div);
                }
            });
            
            talentCooldownDisplay.innerHTML = '';
            if (selectedTalent === 'immortal' && talentCooldown > 0) {
                const remainingSeconds = Math.ceil(talentCooldown / FPS);
                talentCooldownDisplay.innerHTML = `âš”ï¸ å†·å´: <span style="color:#ff4d4d;">${remainingSeconds}s</span>`;
            }
            if (selectedTalent === 'tank' && hasRevived) {
                talentCooldownDisplay.innerHTML = `å¤æ´»æœºä¼š: <span style="color:#aaa;">å·²ä½¿ç”¨</span>`;
            } else if (selectedTalent === 'tank' && !hasRevived) {
                talentCooldownDisplay.innerHTML = `å¤æ´»æœºä¼š: <span style="color:#00ff80;">å¯ç”¨</span>`;
            }
            
            // HUD æ¨¡å¼æ˜¾ç¤ºæ›´æ–°ï¼ˆæ”¯æŒå¤šä¸ªå¨±ä¹æ¨¡å¼ï¼‰
            let modeName = 'æ™®é€šæ¨¡å¼';
            let modeColor = '#00c8ff';
            if (gameMode === 'entertainment_remote') {
                modeName = 'ä¸­é—¨å¯¹ç‹™ (å¨±ä¹)';
                modeColor = '#ff9900';
            } else if (gameMode === 'entertainment_precision') {
                modeName = 'ç²¾å‡†æ‰“å‡» (å¨±ä¹)';
                modeColor = '#ff9900';
            }
            gameModeDisplay.innerHTML = `æ¨¡å¼: <span style="color: ${modeColor};">${modeName}</span>`;
        }

        // --- æˆå°±ç³»ç»Ÿ ---
        const ACHIEVEMENTS = [
            { id: 'first_blood', title: 'ç¬¬ä¸€æ»´è¡€', desc: 'å‡»æ€ä½ çš„ç¬¬ä¸€åªæ•Œäºº', icon: 'ğŸ©¸' },
            { id: 'powerup_collector', title: 'é“å…·æ”¶é›†è€…', desc: 'æ”¶é›† 3 ä¸ªé“å…·', icon: 'ğŸ”‹' },
            { id: 'survivor_revive', title: 'æµ´è¡€é‡ç”Ÿ', desc: 'ä½¿ç”¨å¤©èµ‹å¤æ´»ä¸€æ¬¡', icon: 'ğŸ’Ÿ' }, 
            { id: 'score_100', title: 'ç ´ç™¾', desc: 'è·å¾— 100 åˆ†', icon: 'â­' },
            { id: 'score_1000', title: 'ç ´åƒï¼', desc: 'ç´¯è®¡å¾—åˆ†è¾¾åˆ° 1000', icon: 'ğŸŒŸ' },
            { id: 'hunter_10', title: 'æ€ªç‰©çŒæ‰‹', desc: 'ç´¯è®¡å‡»æ€ 10 ä¸ªæ•Œäºº', icon: 'ğŸ”«' },
            { id: 'bomb_master', title: 'ç‚¸å¼¹å¤§å¸ˆ', desc: 'ä¸€æ¬¡ç‚¸å¼¹è¿æ€è‡³å°‘ 3 ä¸ªæ•Œäºº', icon: 'ğŸ’£' },
            { id: 'boss_slayer', title: 'BOSS å± å¤«', desc: 'å‡»æ€ä¸€ä¸ª BOSS', icon: 'ğŸ‘‘' }
        ];

        let achievementsState = {};

        function loadAchievements() {
            try {
                const raw = localStorage.getItem('ultimate_shooter_achievements');
                achievementsState = raw ? JSON.parse(raw) : {};
            } catch (e) { achievementsState = {}; }
        }
        function saveAchievements() {
            try { localStorage.setItem('ultimate_shooter_achievements', JSON.stringify(achievementsState)); } catch (e) {}
        }

        function unlockAchievement(id) {
            if (achievementsState[id]) return;
            achievementsState[id] = { unlockedAt: Date.now() };
            saveAchievements();
            renderAchievements();
            showAchievementToast(ACHIEVEMENTS.find(a => a.id === id));
        }

        function renderAchievements() {
            const row = document.getElementById('achievementsRow');
            if (!row) return;
            row.innerHTML = '';
            ACHIEVEMENTS.forEach(a => {
                const unlocked = !!achievementsState[a.id];
                const div = document.createElement('div');
                div.className = 'achievement-item ' + (unlocked ? '' : 'locked');
                const statusText = unlocked ? '<div class="achievement-unlocked-badge">å·²è§£é”</div>' : '';
                div.innerHTML = `
                    <div class="achievement-icon">${a.icon}</div>
                    <div class="achievement-title">${a.title}</div>
                    <div class="achievement-desc">${a.desc}</div>
                    ${statusText}
                `;
                row.appendChild(div);
            });
        }

        function showAchievements() {
            renderAchievements();
            toggleOverlay(startScreen, false);
            toggleOverlay(compendiumScreen, false);
            toggleOverlay(talentSelectScreen, false);
            toggleOverlay(pauseScreen, false);
            toggleOverlay(gameOverScreen, false);
            toggleOverlay(achievementsScreen, true);
        }

        function closeAchievements() {
            toggleOverlay(achievementsScreen, false);
            if (isRunning && isPaused) toggleOverlay(pauseScreen, true);
            else if (!isRunning) toggleOverlay(startScreen, true);
        }

        function showAchievementToast(a) {
            if (!a) return;
            const toast = document.createElement('div');
            toast.className = 'achievement-toast';
            toast.innerHTML = `<div style="font-size:18px; font-weight:700; color:#111; background:linear-gradient(90deg,#ffdd00,#ffbb33); padding:6px 8px; border-radius:6px; display:inline-block; margin-bottom:8px;">æ–°æˆå°±</div><div style="font-size:16px; font-weight:700; margin-bottom:6px;">${a.title}</div><div style="font-size:13px; color:#eee">${a.desc}</div>`;
            document.body.appendChild(toast);
            // è§¦å‘æ»‘åŠ¨å…¥åœº
            requestAnimationFrame(() => { toast.classList.add('show'); });
            // è‡ªåŠ¨éšè—
            setTimeout(() => {
                toast.classList.remove('show');
                toast.classList.add('hide');
                setTimeout(() => toast.remove(), 420);
            }, 2200);
        }

        loadAchievements();
        
        function checkCollisions() {
            // 1. ç©å®¶å­å¼¹ <=> æ•Œäºº & é“å…·
            let nextBullets = [];
            const isInstakillActive = selectedTalent === 'instakill';

            playerBullets.forEach(bullet => {
                let hit = false;
                
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    
                    if (checkCollision(bullet, enemy)) {
                        hit = true;
                        
                        // ç¢°æ’å¤„ç†ï¼š Instakill ä¼˜å…ˆï¼Œç„¶åæ˜¯ Bomb
                        if (bullet.type === 'instakill') {
                            enemy.health = 0;
                            explosionSound.currentTime = 0;
                            explosionSound.play().catch(e => console.error('æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆå¤±è´¥', e));
                        } else if (bullet.type === 'bomb') {
                            
                            // ä¿®æ­£ï¼šInstakill å¤©èµ‹å¯¹ Bomb çš„åŠ æˆ
                            const bombDamage = isInstakillActive ? 6 : 3; 
                            const bombRadius = isInstakillActive ? 180 : 120; 
                            explosionSound.currentTime = 0;
                            explosionSound.play().catch(e => console.error('æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆå¤±è´¥', e));

                            explosions.push({x: bullet.x + bullet.width / 2, y: bullet.y + bullet.height / 2, size: 80, frame: 0});

                            // ç»Ÿè®¡æ­¤æ¬¡ç‚¸å¼¹è¿æ€æ•°
                            let killedByThisBomb = 0;
                            enemies.forEach(otherEnemy => {
                                const dist = Math.hypot((otherEnemy.x + otherEnemy.width/2) - (bullet.x + bullet.width/2), (otherEnemy.y + otherEnemy.height/2) - (bullet.y + bullet.height/2));
                                if (dist < bombRadius && otherEnemy.health > 0) { 
                                    otherEnemy.health -= bombDamage; 
                                    if (otherEnemy.health <= 0) {
                                        killedByThisBomb++;
                                        if (otherEnemy.type !== 'boss') { score += otherEnemy.points; }
                                        spawnPowerup(otherEnemy.x + otherEnemy.width/2, otherEnemy.y + otherEnemy.height/2);
                                        explosions.push({ x: otherEnemy.x + otherEnemy.width / 2, y: otherEnemy.y + otherEnemy.height / 2, size: otherEnemy.width * 0.5, frame: 0 });
                                        otherEnemy.health = -999; 
                                    }
                                }
                            });
                            if (killedByThisBomb >= 3) {
                                unlockAchievement('bomb_master');
                            }
                            // æ›´æ–°å•æ¬¡ç‚¸å¼¹æœ€å¤§è¿æ€è®°å½•
                            if (killedByThisBomb > maxBombKills) maxBombKills = killedByThisBomb;
                            // ç‚¸å¼¹å­å¼¹å‡»ä¸­åç›´æ¥é”€æ¯
                            bullet.damage = 0; 
                        } else {
                            enemy.health -= bullet.damage;
                        }
                        
                        // éç‚¸å¼¹å­å¼¹ï¼Œå‡»ä¸­åå³é”€æ¯
                        if (bullet.type !== 'bomb') {
                             bullet.damage = 0; 
                             break;
                        }
                    }
                }

                if (bullet.damage > 0) {
                    nextBullets.push(bullet);
                }
            });
            
            playerBullets = nextBullets;

            // æ•Œäººæ­»äº¡å’Œ Boss é€»è¾‘ 
            enemies = enemies.filter((enemy) => {
                if (enemy.health <= 0) { 
                    if (enemy.health > -999) { 
                         if (enemy.type !== 'boss') {
                             score += enemy.points;
                             explosionSound.currentTime = 0;
                             explosionSound.play().catch(e => console.error('æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆå¤±è´¥', e));
                         }
                         spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                         explosions.push({
                            x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2, 
                            size: enemy.width * 0.5, frame: 0
                         });
                    }
                    // æˆå°±ç»Ÿè®¡ï¼šè®°å½•å‡»æ€æ•°
                    if (enemy.type === 'boss') {
                        bossesKilled++;
                        if (bossesKilled === 1) unlockAchievement('boss_slayer');
                    } else {
                        enemiesKilled++;
                        if (enemiesKilled === 1) unlockAchievement('first_blood');
                        if (enemiesKilled === 10) unlockAchievement('hunter_10');
                    }

                    if (enemy.type === 'boss') {
                        isBossActive = false;
                        score += enemy.points; 
                        
                        if (score > scoreToNextBoss) {
                            score = scoreToNextBoss; 
                        }
                        scoreToNextBoss += 1000;
                    }
                    
                    return false; 
                }
                return true;
            });

            // 2 & 3. ç©å®¶ <=> æ•Œäºº & å­å¼¹ 
            if (invulnerabilityTimer === 0) {
                enemies = enemies.filter((enemy) => {
                    if (checkCollision(player, enemy)) {
                        lives -= 1;
                        invulnerabilityTimer = CONFIG.INVULNERABILITY_DURATION;
                        explosions.push({x: player.x + player.width / 2, y: player.y + player.height / 2, size: player.width * 0.5, frame: 0});
                        explosions.push({x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2, size: enemy.width * 0.7, frame: 0});
                        explosionSound.currentTime = 0;
                        explosionSound.play().catch(e => console.error('æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆå¤±è´¥', e));
                        
                        if (enemy.type !== 'boss') {
                            score += enemy.points;
                        }
                        return false; 
                    }
                    return true;
                });
                
                let nextEnemyBullets = [];
                enemyBullets.forEach(bullet => {
                    if (checkCollision(player, bullet)) {
                        explosionSound.currentTime = 0;
                        explosionSound.play().catch(e => console.error('æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆå¤±è´¥', e));
                        lives -= bullet.damage;
                        invulnerabilityTimer = CONFIG.INVULNERABILITY_DURATION;
                        explosions.push({x: bullet.x + bullet.width/2, y: bullet.y + bullet.height/2, size: 20, frame: 0});
                    } else {
                        nextEnemyBullets.push(bullet);
                    }
                });
                enemyBullets = nextEnemyBullets;
            }


            // 4. ç©å®¶ <=> é“å…· (å¨±ä¹æ¨¡å¼ä¸æ‰è½é“å…·ï¼Œæ­¤é€»è¾‘ä»…åœ¨æ™®é€šæ¨¡å¼ç”Ÿæ•ˆ)
            powerups = powerups.filter(p => {
                if (checkCollision(player, p)) {
                    applyPowerup(p);
                    powerupsCollected++;
                    if (powerupsCollected >= 3) unlockAchievement('powerup_collector');
                    return false;
                }
                return true;
            });
            
            // 5. å¤©èµ‹ç”Ÿå‘½åˆ¤æ–­
            if (lives <= 0) {
                if (selectedTalent === 'immortal' && talentCooldown === 0) {
                    lives = 1; 
                    invulnerabilityTimer = CONFIG.TALENT_IMMORTAL_INVULNERABILITY;
                    talentCooldown = CONFIG.TALENT_IMMORTAL_COOLDOWN;
                } else if (selectedTalent === 'tank' && !hasRevived) {
                    lives = Math.ceil(maxLives / 2); 
                    invulnerabilityTimer = CONFIG.INVULNERABILITY_DURATION * 2; 
                        hasRevived = true;
                        unlockAchievement('survivor_revive');
                } else {
                    endGame();
                }
            }
        }
        
        function updateHUD() {
            hudScore.textContent = score;
            livesBar.style.width = `${(lives / maxLives) * 100}%`;
            updatePowerupDisplay();

            // æˆå°±ï¼šåˆ†æ•°é‡Œç¨‹ç¢‘
            if (score >= 100) unlockAchievement('score_100');
            if (score >= 1000) unlockAchievement('score_1000');
            // å®æ—¶æ›´æ–°æˆå°±é¢æ¿é‡Œçš„è¿›åº¦æ¡ï¼ˆå¦‚æœæ‰“å¼€æˆ–åœ¨åå°ï¼‰
            renderAchievements();
        }

        // --- 14. æ¨¡å¼é€‰æ‹©å’Œå¤©èµ‹é€‰æ‹© ---
        
        function generateModeCards() {
             document.querySelectorAll('.mode-card').forEach(card => {
                 // é¿å…é‡å¤ç»‘å®šäº‹ä»¶
                 if (!card.hasAttribute('data-event-bound')) {
                     card.addEventListener('click', () => selectMode(card));
                     card.setAttribute('data-event-bound', 'true');
                 }
             });
             // å¦‚æœå½“å‰æœ‰é€‰ä¸­æ¨¡å¼ï¼Œé‡æ–°åº”ç”¨é€‰ä¸­æ ·å¼
             if (selectedModeCard) {
                 const card = document.querySelector(`.mode-card[data-mode="${selectedModeCard.getAttribute('data-mode')}"]`);
                 if (card) {
                     card.classList.add('selected');
                     selectTalentButton.disabled = false;
                 }
             }
        }
        
        function selectMode(card) {
            document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('selected'));
            card.classList.add('selected');
            selectedModeCard = card;
            selectTalentButton.disabled = false;
        }
        
        function showModeSelectScreen() {
            // ä¿®å¤ï¼šç¡®ä¿æ‰€æœ‰éå½“å‰å±å¹•éƒ½éšè—
            toggleOverlay(startScreen, false);
            toggleOverlay(compendiumScreen, false);
            toggleOverlay(talentSelectScreen, false);
            toggleOverlay(pauseScreen, false);
            toggleOverlay(gameOverScreen, false);

            toggleOverlay(modeSelectScreen, true);
            generateModeCards(); 
            // æ¯æ¬¡è¿›å…¥æ¨¡å¼é€‰æ‹©æ—¶ï¼Œé‡ç½®æ¨¡å¼é€‰æ‹©çŠ¶æ€
            selectedModeCard = null;
            document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('selected'));
            selectTalentButton.disabled = true;
            // åœ¨æ¨¡å¼é€‰æ‹©ç•Œé¢å…è®¸æ–‡å­—é€‰æ‹©
            document.body.style.userSelect = 'auto';
            // æ¢å¤é¼ æ ‡æ˜¾ç¤º
            canvas.style.cursor = 'default';
        }
        
        function confirmModeAndShowTalentSelect() {
            if (!selectedModeCard) return;
            gameMode = selectedModeCard.getAttribute('data-mode');
            showTalentSelectScreen();
        }
        
        // --- 15. æ¸¸æˆæµç¨‹å‡½æ•° ---

        function formatDescription(text) {
             return text;
        }

        function generateCompendiumContent() {
            compendiumContent.innerHTML = '';
            
            // æ•Œäººå›¾é‰´
            const enemySection = document.createElement('div');
            enemySection.className = 'compendium-section';
            enemySection.innerHTML = '<h3>ğŸ¤– æ•Œäººå›¾é‰´</h3>';
            Object.keys(ENEMY_DETAILS).forEach(key => {
                const data = ENEMY_DETAILS[key];
                let extraInfo = `åˆ†æ•°: ${data.points} | è¡€é‡: ${key === 'boss' ? 'Lvl x ' + data.health_base : data.health}`;
                if (key === 'boss') extraInfo = `è¡€é‡: ? | è§¦å‘åˆ†æ•°: æ¯ 1000 åˆ†`;
                
                enemySection.innerHTML += `
                    <div class="compendium-item">
                        <span class="item-icon">${data.icon}</span>
                        <div class="item-details">
                            <h4>${data.name}</h4>
                            <p>${data.desc}</p>
                            <p style="color:#00ffc3; margin-top: 5px;">${extraInfo}</p>
                        </div>
                    </div>
                `;
            });
            compendiumContent.appendChild(enemySection);
            
            // é“å…·å›¾é‰´
            const powerupSection = document.createElement('div');
            powerupSection.className = 'compendium-section';
            powerupSection.innerHTML = '<h3>ğŸ”‹ é“å…·å›¾é‰´</h3>';
            Object.keys(POWERUP_DETAILS).forEach(key => {
                const data = POWERUP_DETAILS[key];
                
                powerupSection.innerHTML += `
                    <div class="compendium-item">
                        <span class="item-icon">${data.icon}</span>
                        <div class="item-details">
                            <h4>${data.name}</h4>
                            <p>${data.desc}</p>
                            <p style="color:#00ffc3; margin-top: 5px;">æŒç»­æ—¶é—´: ${key === 'heal' ? 'ç¬å‘' : Math.ceil(CONFIG.POWERUP_DURATION / FPS) + 's'}</p>
                        </div>
                    </div>
                `;
            });
            compendiumContent.appendChild(powerupSection);

            // å¤©èµ‹å›¾é‰´
            const talentSection = document.createElement('div');
            talentSection.className = 'compendium-section';
            talentSection.innerHTML = '<h3>âœ¨ å¤©èµ‹å›¾é‰´</h3>';
            TALENTS.forEach(talent => {
                // å›¾é‰´ä¸­ç›´æ¥æ˜¾ç¤ºåŸå§‹æè¿°ï¼Œä¸éœ€è¦è§£æ HTML æ ‡ç­¾
                const rawDesc = talent.desc.replace(/<b[^>]*>|<\/b>/g, '');
                
                talentSection.innerHTML += `
                    <div class="compendium-item">
                        <span class="item-icon">${talent.name.slice(-2)}</span>
                        <div class="item-details">
                            <h4>${talent.name}</h4>
                            <p>${rawDesc}</p>
                        </div>
                    </div>
                `;
            });
            compendiumContent.appendChild(talentSection);
        }
        
        function showCompendium() { 
            if (isRunning) togglePause();
            toggleOverlay(startScreen, false);
            toggleOverlay(modeSelectScreen, false); 
            toggleOverlay(talentSelectScreen, false);
            toggleOverlay(pauseScreen, false);
            toggleOverlay(gameOverScreen, false);
            generateCompendiumContent();
            toggleOverlay(compendiumScreen, true);
        }
        
        function closeCompendium() { 
            toggleOverlay(compendiumScreen, false);
            if (isRunning && isPaused) {
                toggleOverlay(pauseScreen, true);
            } else if (!isRunning) {
                toggleOverlay(startScreen, true);
            }
        }

        function generateTalentCards() {
            talentCardsContainer.innerHTML = '';
            TALENTS.forEach(talent => {
                const card = document.createElement('div');
                card.className = 'talent-card';
                card.setAttribute('data-talent-id', talent.id);
                // ä½¿ç”¨ formatDescription å‡½æ•°ï¼ˆå®ƒç›´æ¥è¿”å›åŒ…å« <b> æ ‡ç­¾çš„ HTML å­—ç¬¦ä¸²ï¼‰
                card.innerHTML = `<h3>${talent.name}</h3><p>${formatDescription(talent.desc)}</p>`;

                // å¦‚æœå½“å‰æ¨¡å¼æ˜¯ ç²¾å‡†æ‰“å‡» (entertainment_precision)ï¼Œåˆ™ç¦ç”¨å¤©èµ‹é€‰æ‹©
                if (gameMode === 'entertainment_precision') {
                    card.style.opacity = '0.5';
                    card.style.cursor = 'not-allowed';
                } else {
                    card.addEventListener('click', () => selectTalent(talent.id));
                }
                talentCardsContainer.appendChild(card);
            });
            // é‡ç½®é€‰ä¸­çŠ¶æ€ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦æœ‰ä¸Šæ¬¡é€‰ä¸­çŠ¶æ€
            // åœ¨ç²¾å‡†æ‰“å‡»æ¨¡å¼ä¸‹ï¼Œå¤©èµ‹ä¸é€‚ç”¨ï¼Œå…è®¸ç›´æ¥ç¡®è®¤
            if (gameMode === 'entertainment_precision') {
                selectedTalent = null;
                document.querySelectorAll('.talent-card').forEach(c => c.classList.remove('selected'));
                selectedTalentHint.innerHTML = 'æœ¬æ¨¡å¼ç¦ç”¨å¤©èµ‹';
                confirmTalentButton.disabled = false;
            } else {
                selectedTalent = null;
                document.querySelectorAll('.talent-card').forEach(c => c.classList.remove('selected'));
                selectedTalentHint.innerHTML = 'è¯·é€‰æ‹©ä¸€ä¸ªå¤©èµ‹';
                confirmTalentButton.disabled = true;
            }
        }

        function selectTalent(id) {
            selectedTalent = id;
            document.querySelectorAll('.talent-card').forEach(card => {
                card.classList.remove('selected');
                if (card.getAttribute('data-talent-id') === id) {
                    card.classList.add('selected');
                }
            });
            confirmTalentButton.disabled = false;
            selectedTalentHint.innerHTML = `å·²é€‰æ‹©å¤©èµ‹ï¼š${TALENTS.find(t => t.id === id).name}`;
        }
        
        function showStartScreen() {
            isRunning = false; // ç¡®ä¿å½»åº•åœæ­¢æ¸¸æˆçŠ¶æ€
            isPaused = false;
            toggleOverlay(modeSelectScreen, false); 
            toggleOverlay(talentSelectScreen, false);
            toggleOverlay(gameOverScreen, false);
            toggleOverlay(compendiumScreen, false);
            toggleOverlay(pauseScreen, false);
            toggleOverlay(startScreen, true);
            if (backgroundMusic) {
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0;
            }
            // æ˜¾ç¤ºä¸»èœå•æ—¶å…è®¸æ–‡å­—é€‰æ‹©
            document.body.style.userSelect = 'auto';
            canvas.style.cursor = 'default';
        }

        function showTalentSelectScreen() {
            // ç¡®ä¿æ¯æ¬¡è¿›å…¥éƒ½é‡ç½®å¤©èµ‹é€‰æ‹©çŠ¶æ€
            selectedTalent = null;
            confirmTalentButton.disabled = true;
            selectedTalentHint.textContent = "è¯·é€‰æ‹©ä¸€ä¸ªå¤©èµ‹";

            toggleOverlay(startScreen, false);
            toggleOverlay(modeSelectScreen, false); 
            toggleOverlay(gameOverScreen, false);
            toggleOverlay(compendiumScreen, false);
            
            generateTalentCards();
            toggleOverlay(talentSelectScreen, true);
            // åœ¨å¤©èµ‹é€‰æ‹©ç•Œé¢å…è®¸æ–‡å­—é€‰æ‹©
            document.body.style.userSelect = 'auto';
            canvas.style.cursor = 'default';
        }

        // --- MODIFIED: æ–°æ¸¸æˆæ—¶æ¸…ç©ºåœºä¸Šæ€ª ---
        function initGame() {
            // ç²¾å‡†æ‰“å‡»æ¨¡å¼ç¦ç”¨å¤©èµ‹ï¼Œå› æ­¤å…è®¸ selectedTalent ä¸º null
            if (gameMode !== 'entertainment_precision' && !selectedTalent) return; 

            // åˆå§‹åŒ–å¤©èµ‹æ•ˆæœï¼šç²¾å‡†æ‰“å‡»æ¨¡å¼å¼ºåˆ¶æ¸…é™¤å¤©èµ‹
            if (gameMode === 'entertainment_precision') {
                selectedTalent = null;
            }

            if (selectedTalent === 'tank') {
                maxLives = 20;
            } else {
                maxLives = 10;
            }
            
            resizeCanvas(); 
            
            player.x = GAME_WIDTH / 2 - player.width / 2;
            player.y = GAME_HEIGHT - 70;
            
            score = 0;
            lives = maxLives;
            gameFrame = 0;
            invulnerabilityTimer = 0;
            talentCooldown = 0;
            hasRevived = false;
            
            // é‡ç½® Boss çŠ¶æ€ï¼Œå¨±ä¹æ¨¡å¼ä¸‹ä¸éœ€è¦
            bossLevel = 0;
            isBossActive = false;
            showBossBanner = false;
            bossBannerTimer = 0;
            scoreToNextBoss = 1000;
            
            // æ¸…ç©ºæ‰€æœ‰åœºä¸Šç‰©ä½“
            playerBullets = [];
            enemyBullets = [];
            powerups = [];
            enemies = [];
            explosions = [];
            activePowerups = []; 
            // ---------------------------------
            
            pauseButton.textContent = 'æš‚åœ (P)';
            
            isRunning = true;
            isPaused = false;
            
            if (backgroundMusic) {
                backgroundMusic.play().catch(e => console.error("èƒŒæ™¯éŸ³ä¹æ’­æ”¾å¤±è´¥:", e));
            }

            // ç²¾å‡†æ‰“å‡»æ¨¡å¼åœ¨æ¸¸æˆè¿›è¡Œæ—¶éšè—ç³»ç»Ÿå…‰æ ‡ä»¥ä¾¿ä½¿ç”¨è‡ªå®šä¹‰ç„å‡†å™¨
            if (gameMode === 'entertainment_precision') {
                canvas.style.cursor = 'none';
            } else {
                canvas.style.cursor = 'default';
            }

            // æ¸¸æˆä¸­ç¦ç”¨é¡µé¢æ–‡å­—é€‰æ‹©
            document.body.style.userSelect = 'none';
            
            toggleOverlay(startScreen, false);
            toggleOverlay(modeSelectScreen, false); 
            toggleOverlay(talentSelectScreen, false);
            toggleOverlay(gameOverScreen, false);
            toggleOverlay(compendiumScreen, false);
            
            loadHighScore();
            updateHUD();
            
            requestAnimationFrame(gameLoop);
        }
        
        function endGame() {
            isRunning = false;
            isPaused = true;
            // åœ¨ä¿å­˜å‰åˆ¤æ–­æ˜¯å¦ä¸ºæ–°çºªå½•ï¼ˆé¿å… saveHighScore è¦†ç›–åˆ¤æ–­æ¡ä»¶ï¼‰
            const prevHigh = highScore;
            const isEntertainment = gameMode !== 'normal';
            const isNewRecord = !isEntertainment && score > prevHigh;

            // ä¿å­˜ï¼ˆsaveHighScore å†…éƒ¨ä¼šæ ¹æ® gameMode å†³å®šæ˜¯å¦å†™å…¥ localStorageï¼‰
            // å…ˆå°è¯•ä¿å­˜ï¼ˆä»…æ™®é€šæ¨¡å¼ä¼šå†™å…¥ï¼‰ï¼Œç„¶åé‡æ–°åŠ è½½ä»¥ç¡®ä¿ HUD æ˜¾ç¤ºæœ€æ–°å€¼
            saveHighScore();
            loadHighScore();
            finalScoreDisplay.innerHTML = `<span style="font-size: 40px; color: #ffdd00;">${score}</span>`;
            
            // ç²¾å‡†æ‰“å‡»æ—¶éšè—ç³»ç»Ÿå…‰æ ‡ï¼Œä½¿ç”¨è‡ªå®šä¹‰ç„å‡†ç‰¹æ•ˆæ›¿ä»£
            if (gameMode === 'entertainment_precision') {
                canvas.style.cursor = 'none';
            } else {
                canvas.style.cursor = 'default';
            }

            requestAnimationFrame(gameLoop);
            let modeText = `æ¨¡å¼: <span style="color: #00ff80;">æ™®é€šæ¨¡å¼</span>`;
            // é»˜è®¤æ˜¾ç¤ºå½“å‰å­˜å‚¨çš„æœ€é«˜åˆ†
            let highscoreText = `æœ€é«˜åˆ†: ${highScore}`;

            if (gameMode === 'entertainment_remote') {
                modeText = `æ¨¡å¼: <span style="color: #ff9900;">ä¸­é—¨å¯¹ç‹™</span>`;
                highscoreText = `å¨±ä¹æ¨¡å¼ä¸è®¡å…¥æœ€é«˜åˆ†ã€‚`;
            } else if (gameMode === 'entertainment_precision') {
                modeText = `æ¨¡å¼: <span style="color: #ff9900;">ç²¾å‡†æ‰“å‡»</span>`;
                highscoreText = `å¨±ä¹æ¨¡å¼ä¸è®¡å…¥æœ€é«˜åˆ†ã€‚`;
            } else if (isNewRecord) {
                highscoreText = `<span style="color: #00ff80;">æ–°çºªå½•ï¼æœ€é«˜åˆ†: ${score}</span>`;
            }

            modeResultText.innerHTML = modeText; // æ˜¾ç¤ºæ¨¡å¼ç»“æœ
            finalHighScoreDisplay.innerHTML = highscoreText;

            // ç»“æŸæ—¶æ¢å¤é¡µé¢å¯é€‰ä¸­æ–‡æœ¬å¹¶æ¢å¤å…‰æ ‡
            document.body.style.userSelect = 'auto';
            canvas.style.cursor = 'default';
            toggleOverlay(gameOverScreen, true);
        }
        
        // --- 16. ä¸»å¾ªç¯ ---
        let lastTime = 0;
        const interval = 1000 / FPS;
        
        function gameLoop(timestamp) {
            if (!isRunning || isPaused) return;
            
            const delta = timestamp - lastTime;
            if (delta < interval) {
                 requestAnimationFrame(gameLoop);
                 return;
            }
            lastTime = timestamp - (delta % interval);

            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // å±å¹•æŠ–åŠ¨: åœ¨ä¸» canvas ä¸Šä¸‹æ–‡åº”ç”¨å¹³ç§»
            ctx.save();
            if (screenShake.time > 0) {
                const sx = (Math.random() * 2 - 1) * screenShake.intensity;
                const sy = (Math.random() * 2 - 1) * screenShake.intensity;
                ctx.translate(sx, sy);
                screenShake.time--;
                // å¼ºåº¦é€æ¸å‡å¼±
                screenShake.intensity *= 0.92;
                if (screenShake.time <= 0) {
                    screenShake.intensity = 0;
                }
            }

            // å¨±ä¹æ¨¡å¼æ²¡æœ‰ BOSS Banner
            if (gameMode === 'normal') {
                drawBossBanner();
            }

            if (gameMode === 'normal' && showBossBanner) {
                 drawBackground();
                 drawPlayer();
            } else {
                drawBackground();
                updatePlayer();
                updatePlayerBullets(); 
                updateEnemyBullets();
                spawnEnemy();
                updateEnemies();
                updatePowerups();
                updateExplosions();
                checkCollisions();

                drawPowerups();
                drawEnemies();
                drawEnemyBullets();
                drawPlayerBullets();
                drawAim();
                drawStrikeLines();
                drawPlayer();
                drawExplosions();

                // ç²’å­åœ¨çˆ†ç‚¸ä¹‹åç»˜åˆ¶
                updateAndDrawParticles();
            }
            ctx.restore();
            
            updateHUD();
            
            gameFrame++;

            requestAnimationFrame(gameLoop);
        }
        
        // --- 17. äº‹ä»¶ç›‘å¬å’Œå¯åŠ¨ ---
        // ç‚¹å‡»å¼€å§‹æ¸¸æˆï¼Œè¿›å…¥æ¨¡å¼é€‰æ‹©
        startButton.addEventListener('click', showModeSelectScreen); 
        
        // æ¨¡å¼é€‰æ‹©ç•Œé¢ç›‘å¬
        selectTalentButton.addEventListener('click', confirmModeAndShowTalentSelect);
        backToMenuFromModeButton.addEventListener('click', showStartScreen);
        backToModeSelectButton.addEventListener('click', showModeSelectScreen); // è¿”å›æ¨¡å¼é€‰æ‹©
        
        confirmTalentButton.addEventListener('click', initGame); 

        compendiumButton.addEventListener('click', showCompendium); 
        closeCompendiumButton.addEventListener('click', closeCompendium);
        // æˆå°±é¢æ¿æŒ‰é’®
        const achievementsButton = document.getElementById('achievementsButton');
        const closeAchievementsButton = document.getElementById('closeAchievementsButton');
        if (achievementsButton) achievementsButton.addEventListener('click', showAchievements);
        if (closeAchievementsButton) closeAchievementsButton.addEventListener('click', closeAchievements);
        
        resumeButton.addEventListener('click', togglePause);
        // æ¸¸æˆç»“æŸé‡æ–°å¼€å§‹ï¼Œå›åˆ°æ¨¡å¼é€‰æ‹©
        restartButton.addEventListener('click', showModeSelectScreen); 
        backToMenuFromGameOverButton.addEventListener('click', showStartScreen);
        pauseButton.addEventListener('click', togglePause);
        
        // æš‚åœç•Œé¢-é‡æ–°å¼€å§‹æŒ‰é’®ç›‘å¬
        showRestartConfirmButton.addEventListener('click', showRestartConfirmModal);
        cancelRestartButton.addEventListener('click', hideRestartConfirmModal);
        confirmRestartButton.addEventListener('click', () => {
             hideRestartConfirmModal();
             // ç¡®è®¤é‡æ–°å¼€å§‹ï¼Œå›åˆ°æ¨¡å¼é€‰æ‹©é¡µ
             showModeSelectScreen(); 
        });

        window.addEventListener('resize', () => {
             resizeCanvas();
             if (!isRunning) {
                 loadHighScore();
                 updateHUD();
             }
        });

        // åˆå§‹åŒ–
        resizeCanvas();
        loadHighScore();
        initStars();
        drawBackground();
        renderAchievements();
        toggleOverlay(startScreen, true); 
    </script>
</body>
</html>